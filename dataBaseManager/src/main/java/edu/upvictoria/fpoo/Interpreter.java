package edu.upvictoria.fpoo;

import static edu.upvictoria.fpoo.TokenType.*;

import java.io.File;
import java.util.*;

/**
 * This class will interpret the abstract syntax tree generated by the parser
 */
/**
 * Voy a llamar a tabla, tabla debe de recibir un archivo csv, luego debe de
 * transformar el archivo csv en una tabla
 */
public class Interpreter
        implements Clause.Visitor<Void>,
        Expression.Visitor<Object> {
    private String path;
    Table table;
    int index;

    void interpret(Clause clause) {
        excecute(clause);
    }

    private void excecute(Clause clause) {
        clause.accept(this);
    }

    // Use clause
    @Override
    public Void useClause(Clause.UseClause clause) {
        File file = new File(clause.path);

        // check if the path exists
        if (!file.exists()) {
            throw new RuntimeException("The path does not exist");
        }

        // check if there are files in the path
        File[] files = file.listFiles();
        if (files != null) {
            for (File f : files) {
                if (f.isFile() && f.getName().toUpperCase().endsWith(".csv")) {
                    System.out.println("Found CSV file: " + f.getName());
                }
            }
        }

        path = clause.path;

        return null;
    }

    // create Clause
    @Override
    public Void createClause(Clause.CreateClause clause) {
        /**
         * check if the table exists
         * if it does not exist create it
         * if it exists throw an error
         */
        File file = new File(path + clause.name + ".csv");
        if (file.exists()) {
            throw new RuntimeException("The table already exists");
        }

        // create the table
        Table table = new Table();

        // TODO: create the table and do all that stuff
        return null;
    }

    // drop clause
    @Override
    public Void dropClause(Clause.DropClause clause) {
        return null;
    }

    // select clause
    @Override
    public Void selectClause(Clause.SelectClause clause) {
        // List<String> columns, String table_name, Expression
        // where_expression, List<String> columns_order, int limit
        // load table using the from clause
        visit_from_clause(clause);

        // filter with the where clause
        visit_where_clause(clause);

        // order the table using ORDER_BY
        visit_order_by_clause(clause);

        // limit the table using LIMIT
        visit_limit_clause(clause);

        return null;
    }

    private void visit_from_clause(Clause.SelectClause clause) {
        // load table using the from clause
        File csvFile = new File(path + clause.table_name + ".csv");
        File metaFile = new File(path + clause.table_name + ".meta");

        if (!csvFile.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        Table table = Table.load(csvFile, metaFile);
        if (table == null) {
            throw new RuntimeException("Error loading the table");
        }

        this.table = table;

    }

    /**
     * Pseudocode:
     * def where_clause(where_clause: Clause) -> Void:
     * new_table = new Table()
     * # Each row of the table is evaluated
     * for row in table.get_rows():
     * # Expr functions return boolean
     * if evaluate(where_clause.expr):
     * new_table.add_row(row)
     * 
     * @param clause
     */
    private void visit_where_clause(Clause.SelectClause clause) {
        Table partialTable = new Table();
        for (HashMap<String, Object> row : table.getRows()) {
            // evaluate returns a boolean if the expression is correct for each row
            if (evaluate(clause.where_expression, row)) {
                partialTable.addRow(row);
            }
        }
    }

    /**
     * Evaluate a expression
     */
    private Object evaluate(Expr expr) {
        return expr.accept(this);
    }

    /********************************************************************/
    /****************************** Expressions Visitors **********************/
    @Override
    public Object visitBinaryExpression(Expression expr) {
        Object left = evaluate(expr.left);
        Object right = evaluate(expr.right); 
        
        switch (expr.operator.type) {
            case PLUS:
                if (left instanceof Double && right instanceof Double)
                    return (double)left + (double)right;
                if (left instanceof String && right instanceof String) //Handle concatenation
                    return (String)left + (String)right;
                throw new RuntimeException("Operands must be two numbers or two strings.");
            case MINUS:
                return (double)left - (double)right;
            case SLASH:
                checkNumberOperand(right);
                return (double)left / (double)right;
            case STAR:
                checkNumberOperand(right);
                return (double)left * (double)right;
            case GREATER:
                checkNumberOperands(left, right);
                return (double)left > (double)right;
            case GREATER_EQUAL:
                checkNumberOperands(left, right);
                return (double)left >= (double)right;
            case LESS:
                checkNumberOperands(left, right);
                return (double)left < (double)right;
            case LESS_EQUAL:
                checkNumberOperands(left, right);
                return (double)left <= (double)right;
            case BANG_EQUAL:
                return !isEqual(left, right);
            case EQUAL_EQUAL:
                return isEqual(left, right);
            case EQUAL:
                return isEqual(left, right);
            case AND:
                return (boolean)left && (boolean)right;
            case OR:
                return (boolean)left || (boolean)right;
        }
        return null;
    }

    /**
     * Checks if an object is a number
     * @param operator
     * @param operand
     */
    private void checkNumberOperand(Object operand) {
        if (operand instanceof Double) return;
        throw new RuntimeException("Operand must be a number.");
    }

    private void checkNumberOperands(Object left, Object right) {
        if (left instanceof Double && right instanceof Double) return;
        
        throw new RuntimeException("Operands must be numbers.");
    }

    private boolean isEqual(Object a, Object b) {
        if (a == null && b == null) return true;
        if (a == null) return false;
        return a.equals(b);
    }

    @Override
    public Object visitGroupingExpression(Expression.Grouping expression, HashMap<String, Object> row) {
        return evaluate(expression.expression, row);
    }

    @Override
    public Object visitLiteralExpression(Expression.Literal expression, HashMap<String, Object> row) {
        return expression.value;
    }

    @Override
    public Object visitUnaryExpression(Expression.Unary expression, HashMap<String, Object> row) {
        Object right = expression.right.accept(this, row);

        switch (expression.operator.type) {
            case MINUS:
                return -(int) right;
            case BANG:
                return !((boolean) right);
        }

        return null;
    }

}
