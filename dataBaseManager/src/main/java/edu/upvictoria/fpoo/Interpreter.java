package edu.upvictoria.fpoo;

import static edu.upvictoria.fpoo.TokenType.*;

import java.io.File;
import java.util.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * TODO: right now is not necessary to implement things for the meta data but at the future it will
 */
/**
 * This class will interpret the abstract syntax tree generated by the parser
 */
/**
 * Voy a llamar a tabla, tabla debe de recibir un archivo csv, luego debe de
 * transformar el archivo csv en una tabla
 */
public class Interpreter
        implements Clause.Visitor<Void>, Expression.Visitor<Object> {
    // variables
    private String path;
    Table table;
    HashMap<String, Object> currentRow = null;
    // int index;

    void interpret(Clause clause) {
        excecute(clause);
    }

    private void excecute(Clause clause) {
        clause.accept(this);
    }

    // Use clause
    @Override
    public Void useClause(Clause.UseClause clause) {
        String path = "";

        // eliminate the quotes
        path = clause.path;
        path = path.replace("\"", "");

        if (!path.startsWith("/")) {
            path = System.getProperty("user.dir") + "/" + path;
        }

        // check if the path exists
        Path pathy = Paths.get(path);
        boolean exists = Files.exists(pathy);
        if (!exists) {
            throw new RuntimeException("The path" + clause.path + " does not exist");
        }

        // set the path
        this.path = path;
        System.out.println("DataBase path set to: " + this.path);

        return null;
    }

    // delete Clause
    @Override
    public Void deleteClause(Clause.DeleteClause clause) {
        File file = new File(path + clause.table_name + ".csv");

        if (!file.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        Table table = Table.load(file);
        if (table == null) {
            throw new RuntimeException("Error loading the table");
        }

        // delete the row in the table
        visit_where_clause_delete(clause, table);

        // save the table
        table.save(file);

        return null;
    }

    private void visit_where_clause_delete(Clause.DeleteClause clause, Table table) {
        List<String> columnNames = table.getColumnNames();

        Iterator<HashMap<String, Object>> iterator = table.getRows().iterator();
        while (iterator.hasNext()) {
            HashMap<String, Object> row = iterator.next();
            currentRow = row;
            if ((Boolean) evaluate(clause.where_expression)) {
                iterator.remove();
            }
        }

        // write at the beginning the column names
        table.writeColumnNames(columnNames);

        this.table = table;
        this.currentRow = null;
    }

    // create Clause
    @Override
    public Void createClause(Clause.CreateClause clause) {
        /**
         * check if the table exists
         * if it does not exist create it
         * if it exists throw an error
         */
        File file = new File(path + clause.name + ".csv");
        if (file.exists()) {
            throw new RuntimeException("The table already exists");
        }

        // create the table
        Table table = new Table();

        // add the columns
        // clause.columnsDefinition =
        // [1][1] = Column name
        // [1][2] = Column type
        // [1][2 ... n] = Constraints
        // [2][1] = Column name
        // [2][2] = Column type
        // [2][2 ... n] = Constraints
        for (List<String> column : clause.columnsDefinition) {
            table.addColumn(column.get(0), column.get(1));
        }

        // save the table
        table.save(file);

        return null;
    }

    // insert clause
    @Override
    public Void insertClause(Clause.InsertClause clause) {
        File file = new File(path + clause.lexeme + ".csv");

        if (!file.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        Table table = Table.load(file);
        if (table == null) {
            throw new RuntimeException("Error loading the table");
        }

        // insert the row in the table
        table.addRow(clause.valuesMap);

        // save the table
        table.save(file);

        return null;
    }

    // update clause
    @Override
    public Void updateClause(Clause.UpdateClause clause) {
        File file = new File(path + clause.table_name + ".csv");

        if (!file.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        Table table = Table.load(file);
        if (table == null) {
            throw new RuntimeException("Error loading the table");
        }

        // update the row in the table
        visit_where_clause_update(clause, table);

        // save the table
        table.save(file);

        return null;
    }

    private void visit_where_clause_update(Clause.UpdateClause clause, Table table) {
        List<String> columnNames = table.getColumnNames();
        for (HashMap<String, Object> row : table.getRows()) {
            currentRow = row;
            if ((Boolean) evaluate(clause.where_expression)) {
                for (String column : clause.valuesMap.keySet()) {
                    row.put(column, clause.valuesMap.get(column));
                }
            }
        }
        // write at the beginning the column names
        table.writeColumnNames(columnNames);

        this.table = table;
        this.currentRow = null;
    }

    // drop clause
    @Override
    public Void dropClause(Clause.DropClause clause) {
        File file = new File(path + clause.lexeme + ".csv");
        if (!file.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        // delete the file
        file.delete();

        return null;
    }

    // select clause
    @Override
    public Void selectClause(Clause.SelectClause clause) {
        // load table using the from clause
        visit_from_clause(clause);

        // filter with the where clause
        if (clause.where_expression != null)
            visit_where_clause(clause);

        // order the table using ORDER_BY
        if (clause.columns_order != null)
            visit_order_by_clause(clause.columns_order);

        // limit the table using LIMIT
        if (clause.limit != -1)
            visit_limit_clause(clause);

        // select the column on the table using select
        if (clause.columns != null)
            visit_select_clause(clause);

        // print the table
        table.print();

        return null;
    }

    private void visit_from_clause(Clause.SelectClause clause) {
        // load table using the from clause
        File csvFile = new File(path + clause.table_name + ".csv");

        if (!csvFile.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        Table table = Table.load(csvFile);
        if (table == null) {
            throw new RuntimeException("Error loading the table");
        }

        this.table = table;

    }

    /**
     * Pseudocode:
     * def where_clause(where_clause: Clause) -> Void:
     * new_table = new Table()
     * # Each row of the table is evaluated
     * for row in table.get_rows():
     * # Expr functions return boolean
     * if evaluate(where_clause.expr):
     * new_table.add_row(row)
     * 
     * @param clause
     */
    private void visit_where_clause(Clause.SelectClause clause) {
        Table partialTable = new Table();
        for (HashMap<String, Object> row : table.getRows()) {
            currentRow = row;
            if ((Boolean) evaluate(clause.where_expression)) {
                partialTable.addRow(row);
            }
        }
        this.table = partialTable;
        this.currentRow = null;
    }

    /**
     * VisitOrderBy
     * 
     * @param expr
     * @return
     */
    private void visit_order_by_clause(List<String> columns_order) {
        ArrayList<String> column_order = new ArrayList<String>(columns_order);

        // iterate by 2 bc the list is in this order (column_to_order, ASC/DESC)
        for (int i = 0; i < column_order.size(); i += 2) {
            String column = column_order.get(i);
            String order = column_order.get(i + 1);

            // sort the table
            if (order == "ASC") {
                table.sort(column);
            } else {
                table.sortReverse(column);
            }
        }

    }

    private void visit_limit_clause(Clause.SelectClause clause) {
        // limit the table using LIMIT
        if (clause.limit != -1) {
            table.limit(clause.limit);
        }

    }

    private void visit_select_clause(Clause.SelectClause clause) {
        // select the column on the table using select
        // if the columns are empty select all the columns
        if (clause.columns.isEmpty()) {
            return;
        }

        // select the columns
        table.filterColumns(clause.columns);
    }

    /**
     * Evaluate a expression
     * 
     * @param expr
     * @return Object
     */
    private Object evaluate(Expression expr) {
        return expr.accept(this);
    }

    /**************************************************************************/
    /****************************** Expressions Visitors **********************/
    /**************************************************************************/
    // SELECT * FROM tablita WHERE nombre = "Juan" AND edad = 20 OR edad = 30;
    @Override
    public Object visitBinaryExpression(Expression.Binary expr) {
        Object left = evaluate(expr.left);
        Object right = evaluate(expr.right);

        switch (expr.operator.type) {
            case PLUS:
                checkNumberOperands(left, right);
                return (double) left + (double) right;
            case MINUS:
                checkNumberOperands(left, right);
                return (double) left - (double) right;
            case SLASH:
                checkNumberOperands(left, right);
                return (double) left / (double) right;
            case STAR:
                checkNumberOperands(left, right);
                return (double) left * (double) right;
            case GREATER:
                checkNumberOperands(left, right);
                return (double) left > (double) right;
            case GREATER_EQUAL:
                checkNumberOperands(left, right);
                return (double) left > (double) right;
            case LESS:
                checkNumberOperands(left, right);
                return (double) left < (double) right;
            case LESS_EQUAL:
                checkNumberOperands(left, right);
                return (double) left <= (double) right;
            // TODO: Should work for strings too (i.e. checkStrNumOperands)
            case BANG_EQUAL:
                return !isEqual(left, right);
            case EQUAL_EQUAL:
                return isEqual(left, right);
            case EQUAL:
                return isEqual(left, right);
            // TODO: Check this methods
            // case AND:
            //     return (boolean) left && (boolean) right;
            // case OR:
            //     return (boolean) left || (boolean) right;
        }

        return null;
    }

    /**
     * Checks for the visitBinary expression
     */
    private void checkNumberOperand(Object operand) {
        if (operand instanceof Double)
            return;
        throw new RuntimeException("Operand must be a number.");
    }

    private void checkNumberOperands(Object left, Object right) {
        if (left instanceof Double && right instanceof Double)
            return;
        throw new RuntimeException("Operands must be numbers.");
    }

    private boolean checkStringOperands(Object left, Object right) {
        if (left instanceof String && right instanceof String)
            return false;

        throw new RuntimeException("Operands must be strings.");
    }

    private boolean isEqual(Object a, Object b) {
        if (a == null && b == null)
            return true;
        if (a == null)
            return false;
        return a.equals(b);
    }

    @Override
    public Object visitGroupingExpression(Expression.Grouping expression) {
        return evaluate(expression.expression);
    }

    @Override
    public Object visitLiteralExpression(Expression.Literal expression) {
        if (expression.isColumnName) {
            return currentRow.get(expression.value);
        } else {
            return expression.value;
        }
    }

    @Override
    public Object visitUnaryExpression(Expression.Unary expression) {
        Object right = expression.right.accept(this);

        switch (expression.operator.type) {
            case MINUS:
                return -(int) right;
            case BANG:
                return !((boolean) right);
        }

        return null;
    }

}
