package edu.upvictoria.fpoo;

import java.io.File;
import java.util.*;

/**
 * This class will interpret the abstract syntax tree generated by the parser
 */
/**
 * Voy a llamar a tabla, tabla debe de recibir un archivo csv, luego debe de
 * transformar el archivo csv en una tabla
 */
public class Interpreter
        implements Clause.Visitor<Void>, 
        Expression.Visitor<Object> 
    {
    private String path;
    Table table;

    void interpret(Clause clause) {
        excecute(clause);
    }

    private void excecute(Clause clause) {
        clause.accept(this);
    }

    // Use clause
    @Override
    public Void useClause(Clause.UseClause clause) {
        File file = new File(clause.path);

        // check if the path exists
        if (!file.exists()) {
            throw new RuntimeException("The path does not exist");
        }

        // check if there are files in the path
        File[] files = file.listFiles();
        if (files != null) {
            for (File f : files) {
                if (f.isFile() && f.getName().toUpperCase().endsWith(".csv")) {
                    System.out.println("Found CSV file: " + f.getName());
                }
            }
        }

        path = clause.path;

        return null;
    }

    // create Clause
    @Override
    public Void createClause(Clause.CreateClause clause) {
        /**
         * check if the table exists
         * if it does not exist create it
         * if it exists throw an error
         */
        File file = new File(path + clause.name + ".csv");
        if (file.exists()) {
            throw new RuntimeException("The table already exists");
        }

        // create the table
        Table table = new Table(file);

        // TODO: create the table and do all that stuff
        return null;
    }

    // select clause
    @Override
    public Void selectClause(Clause.SelectClause clause) {
        // List<String> columns, String table_name, Expression
        // where_expression, List<String> columns_order, int limit
        // load table using the from clause
        visit_from_clause(clause);

        // filter with the where clause
        visit_where_clause(clause);

        // order the table using ORDER_BY
        visit_order_by_clause(clause);

        // limit the table using LIMIT
        visit_limit_clause(clause);


        return null;
    }

    private void visit_from_clause(Clause.SelectClause clause) {
        // load table using the from clause
        File file = new File(path + clause.table_name + ".csv");
        if (!file.exists()) {
            throw new RuntimeException("The table does not exist");
        }

        try {
            Table table = Table.load(file.getAbsolutePath(), file.getAbsolutePath() + ".meta");
        } catch (Exception e) {
            throw new RuntimeException("Error loading the table");
        }
    }

    private void visit_where_clause(Clause.SelectClause clause) {
        // filter with the where clause
        Table parsialTable = new Table();
        // Evaluate each row on the table
        for (HashMap<String, Object> row : table.getRows()) {
            if (evaluate(clause.where_expression, row)) {
                parsialTable.addRow(row);
            }
        }
    }

    // drop clause
    @Override
    public Void dropClause(Clause.DropClause clause) {
        return null;
    }

    /**
     * Evaluate a expression
     */
    private boolean evaluate(Expression expression, HashMap<String, Object> row) {
        return (boolean) expression.accept(this, row);    
    }

    /********************************************************************/
    // Expression visitors
    @Override
    public Object visitBinaryExpression(Expression.Binary expression, HashMap<String, Object> row) {
        Object left = expression.left.accept(this, row);
        Object right = expression.right.accept(this, row);

        switch (expression.operator.type) {
            case GREATER:
                return (int) left > (int) right;
            case GREATER_EQUAL:
                return (int) left >= (int) right;
            case LESS:
                return (int) left < (int) right;
            case LESS_EQUAL:
                return (int) left <= (int) right;
            case EQUAL_EQUAL:
                return left.equals(right);
            case BANG_EQUAL:
                return !left.equals(right);
            case PLUS:
                return (int) left + (int) right;
            case MINUS:
                return (int) left - (int) right;
            case STAR:
                return (int) left * (int) right;
            case SLASH:
                return (int) left / (int) right;
        }

        return null;
    }

    @Override
    public Object visitGroupingExpression(Expression.Grouping expression, HashMap<String, Object> row) {
        return expression.expression.accept(this, row);
    }

    @Override
    public Object visitLiteralExpression(Expression.Literal expression, HashMap<String, Object> row) {
        return expression.value;
    }

    @Override
    public Object visitUnaryExpression(Expression.Unary expression, HashMap<String, Object> row) {
        Object right = expression.right.accept(this, row);

        switch (expression.operator.type) {
            case MINUS:
                return -(int) right;
            case BANG:
                return !((boolean) right);
        }

        return null;
    }

}
